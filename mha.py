import sys                       # Used for command line options
import numpy as num              # Gerneral math functions
import matplotlib.pyplot as plot # plotting


###############################################################
#### Calculate Norm and return N = 1/Norm for simplisity I will use a basic numarical intergartion method here.
def NormCal(mu,omega,alpha,beta):
    n = 1000 # number of parts the domine is bing split into
    # set a general range [-4,4]centered on mu
    Rmin = -4 + mu
    Rmax = 4 + mu
    dh=(Rmax-Rmin)/n
    x=Rmin
    N=0
    for i in range(n):
        if x>alpha:
            N=N+(num.exp(-num.square((x-mu)/omega)/2.0)-beta*(x-alpha))
        else:
            N=N+(num.exp(-num.square((x-mu)/omega)/2.0))
        x=x+dh
    return 1/N


################################################################
#### generate prob from F(x)
def ModGause(mu,omega,alpha,beta,x):
  if x>alpha:
    prob=(num.exp(-num.square((x-mu)/omega)/2.0)-beta*(x-alpha))
  else:
    prob=(num.exp(-num.square((x-mu)/omega)/2.0))
  return prob


###############################################################
####### Main program  

steps = 10000

##################################################################################
##################################################################################
### takeing the inputs for the parameters or using defults
if len(sys.argv)>1:
  mu=int(sys.argv[1])
  omega=int(sys.argv[2])
  alpha=float(sys.argv[3])
  beta=float(sys.argv[4])
else:
  mu=0.0
  omega=1.0
  alpha=1.0
  beta=0.5

# create the norm N 
# N = NormCal(mu,omega,alpha,beta)
# setting up initial value for x
x = []
x.append(1)
xp = ModGause(mu,omega,alpha,beta,x[0])
RanOmega=omega/2 # setting to sd for the step generator 

# preforming the sampling
for i in range(steps):
    y=num.random.normal(x[i],RanOmega) # move x by a random number generated by a gaussian centered at x[i]
    # num.random.normal give a random number centerd on x[i] with an sd of RanOmega 
    # this is used so as to have a symmetric generator function g giving g(xt|xi)/g(xi|xt)=1
    
    yp = ModGause(mu,omega,alpha,beta,y)
    if (yp/xp)>1:
        x.append(y)
        xp=yp
    else:
        if num.random.rand()< (yp/xp):
            x.append(y)
            xp=yp
        else:
            x.append(x[i])


#########################################
##### ploting
n_bins = 40

fig, axs = plot.subplots(tight_layout=True)
axs.hist(x, bins=n_bins)
plot.show()