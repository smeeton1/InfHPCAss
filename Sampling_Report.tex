\documentclass{article}

\usepackage[numbers,sort&compress]{natbib}
\usepackage{url}
\usepackage{hyperref}



\begin{document}

\section{Question 1}

\subsection{Rejection Sampling}

\begin{itemize}
\itemsep-0.3cm 
\item This method is commonly used for quantum measurements.\citep{Rivas2011} \\
\item I have written code in multiple languages to measure systems using this method \\
\item Can some times require the generation of throw away random numbers before generating the values to be used. \\
\item In the case of normalized distributions is very nice to work with. Other wise need to scale the generator function \citep{JakeRS}\\
\item In the case here can lead to many rejection \\
\item Can reduce the rejection rate by using a gaussian envelope \citep{RelSRS}\\
\item This method is very easy to paralyze. \\
\end{itemize}




\subsection{Markov Chain Monte Carlo}

\begin{itemize}
\itemsep-0.3cm 
\item Follows a random walk\citep{robert2016metropolishastingsalgorithm} \\
\item Could get stuck in a region of $f(x)$ \\
\item May need a burnin time if initial guess is bad\citep{DMHA}\\
\item No need to calculate the norm\\ 
\item Need to choose an appropriate step generator \\
\end{itemize}

\subsection{Inverse Transform Sampling}

\begin{itemize}
\itemsep-0.3cm 
\item Need to create an inverse of the function \\
\item Best to do that numerically \\
\item Would need very small $\Delta$ as continuous\\
\item Memory usage high to store array for inverse of p(x)\\
\item In the given example each probability will have to x values\\
\item Need flip coin to determine if grater then or less then $\mu$\\
\item Is non-continues \citep{ITPCDF}\citep{KKCDF}
\end{itemize}

\section{Question 2}

The code was written in python and implemented the Markov Chain Monte Carlo. The code can be found in the file mha.py. I choses the Metropolisâ€“Hastings algorithm as it does not need the calculation of the norm. 

\section{Question 3}


\section{Question 4}

In the case of specialized hardware changes I would make would be to put the calculation of p(x) onto the accelerator. I would set it up so all the calculations concerning the probability would stay on the accelerator.  In the case of multiple processor I would set up a walker on each processor to run independently and then sum at the end.


\bibliographystyle{plain}
\bibliography{inf.bib}{}%



\end{document}